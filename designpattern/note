A. 实际原则

B．创建型模式
简单（静态）工厂模式：由一个工厂对象决定创建出哪种实例
工厂方法模式（虚拟构造子模式/多态性工厂模式）：定义一个创建实例对象的工厂接口，将实际创建工作推迟到子类中。
抽象工厂模式：最为抽象最具一般性，向客户端提供一个接口，使客户端在不必指定实例的具体类型的情况下创建多个实例族的实例对象。
单例模式：只能得到一个对象实例，构造方法私有。
建造者模式：将复杂对象的构建与其表示分开，使同样的构建过程可以创建不同的表示。
原型模式：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象
C．结构型模式
适配器模式：将一个接口转换成客户希望的另一个接口
缺省适配模式：为接口提供缺省实现以供扩展。使得子类只需覆盖这个缺省实现的个别方法，而无须去实现中的每个方法。JDK1.8中了提供了为接口添加默认实现的新特性
组合（部分-整体）模式：将对象组合成树形结构以表示“部分-整体”的层次结构
装饰器模式：动态给对象添加额外职责，比通过生成子类来增加功能更加灵活
代理模式：提供代理以控制对原对象的访问。关键：代理与原对象共用一个接口
享元模式：运用共享技术有效地支持大量的细粒度对象
外观（门面）模式：为一组接口提供一个一致的接口，体现了DIP和LoD原则
桥接模式：将抽象部分与其实现部分分离，使它们都可以独立变化，可实现多角度分类
D．行为型模式
不变模式：对象在创建之后就不在变化
策略模式：定义一系列形式相同实现不同的算法，减少耦合，封装变化
模板方法模式：定义一个操作中算法的骨架，而将一些具体步骤延迟到子类
观察者模式(发布-订阅模式)：定义一种一对多的依赖关系，让多个观察者对象同时监听某一个通知者对象
迭代器模式：提供顺序访问一个聚合中元素的方法。不常用，因为语言本身已内置
职责链模式：使多个对象都有机会获得机会处理请求。这些对象连成一条链。减少请求得与接收者的耦合。如过滤器
命令模式：将请求封装成一个对象，以使你可用不同的请求对客户端进行参数化；可对请求进行排除、记录日志、或撤销操作
备忘录模式：在不破坏封装的前提下捕获一个对象的内部状态，并在该对象外部保存此状态
状态模式：当一个状态改变时，允许改变其行为，看其来像是改变了其类。（将复杂的条件判断转移到多个小类中）
访问者模式：表示一个作用于某对象结构中的各元素的操作。把数据处理与数据结构分开
解释器模式：对一个语言定义一个文法的表示，并定义一个解释器，来解释语言中的句子，如正则表达式，浏览器。通过解释执行
中介者(调停者)模式：用一个中介对象来封装一系列的对象交互。应用于星形结构的对象关系中
