1.缓存和数据库双写一致性问题
2.缓存雪崩问题
3.缓存击穿问题
4.缓存的并发竞争问题

单线程的redis为什么这么快
(一)纯内存操作
(二)单线程操作，避免了频繁的上下文切换
(三)采用了非阻塞I/O多路复用机制 ?

redis数据类型
1.String 一般做一些复杂的计数功能的缓存。
2.hash
这里value存放的是结构化的对象，比较方便的就是操作其中的某个字段。
3.list
使用List的数据结构，可以做简单的消息队列的功能。另外还有一个就是，可以利用lrange命令，做基于redis的分页功能，性能极佳，用户体验好。
4.set
因为set堆放的是一堆不重复值的集合。所以可以做全局去重的功能。
另外，就是利用交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。
5.sorted set
sorted set多了一个权重参数score,集合中的元素能够按score进行排列。可以做排行榜应用，取TOP N操作。另外，参照另一篇《分布式之延时任务方案解析》，该文指出了sorted set可以用来做延时任务。最后一个应用就是可以做范围查找。

redis的过期策略以及内存淘汰机制☆☆☆
过期策略（Redis中同时使用了惰性过期和定期过期两种过期策略。）
定时过期：该策略可以立即清除过期的数据，但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。
惰性过期：只有当访问一个key时，才会判断该key是否已过期，过期则清除。
定期过期：折中方案，每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。

内存淘汰策略（用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据。）
noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。
allkeys-lru：内存不足时，在键空间中，移除最近最少使用的key。
allkeys-random：内存不足时，在键空间中，随机移除某个key。
--定期
volatile-lru：内存不足时，并且设置了 expire，在过期键中移除最近最少使用的key。
volatile-random：内存不足时，并且设置了 expire，在过期键中随机移除某个key。
volatile-ttl：内存不足时，并且设置了 expire，在过期键中有更早过期时间的key优先移除。

Redis的内存淘汰策略的选取并不会影响过期的key的处理。内存淘汰策略用于处理内存不足时的需要申请额外空间的数据；过期策略用于处理过期的缓存数据。
volatile-lru 和 volatile-random 策略主要应用场景是: 既有缓存,又有持久key的实例中。 一般来说, 像这类场景, 应该使用两个单独的 Redis 实例。
设置 expire 会消耗额外的内存, 所以使用 allkeys-lru 策略, 可以更高效地利用内存, 因为这样就可以不再设置过期时间了。

Redis中数据存储模式有2种：cache-only,persistence;
cache-only即只做为“缓存”服务，不持久数据，数据在服务终止后将消失
persistence为内存中的数据持久备份到磁盘文件，在服务重启后可以恢复。
持久化分为：Redis DataBase(RDB)、Append-only file(AOF)
RDB（间隔时间、变更次数）:
在某个时间点（redis.conf配置，比如m秒内有n个key发生变化触发）将数据写入临时文件，持久化结束后，用临时文件替换上次的文件，达到数据恢复。
优点：使用单独的子进程进行持久化，主进程不会进行IO操作?保证性能
缺点：RDB是间隔一段时间进行持久化，如果持久化之间redis发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候。
AOF：
将操作+数据以指令的方式追加到操作日志文件的尾部，append成功后才进行实际的数据变更。日志文件保存了历史操作记录，当server需要恢复数据时，直接恢复日志文件。类似mysql的bin.log,zk的txn.log。aof文件内容是字符串，方便阅读和查看。
优点：能保证较高的数据完整性；支持redis-check-aof修复日志；AOF文件没被rewrite之前（文件过大时会对命令进行合并重写），可以删除其中的某些命令（比如误操作的flushall）。
缺点：AOF文件比RDB文件大，且恢复速度慢。
同步方式：
